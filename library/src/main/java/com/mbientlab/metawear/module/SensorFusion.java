/*
 * Copyright 2014-2015 MbientLab Inc. All rights reserved.
 *
 * IMPORTANT: Your use of this Software is limited to those specific rights granted under the terms of a software
 * license agreement between the user who downloaded the software, his/her employer (which must be your
 * employer) and MbientLab Inc, (the "License").  You may not use this Software unless you agree to abide by the
 * terms of the License which can be found at www.mbientlab.com/terms.  The License limits your use, and you
 * acknowledge, that the Software may be modified, copied, and distributed when used in conjunction with an
 * MbientLab Inc, product.  Other than for the foregoing purpose, you may not use, reproduce, copy, prepare
 * derivative works of, modify, distribute, perform, display or sell this Software and/or its documentation for any
 * purpose.
 *
 * YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY
 * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
 * NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL MBIENTLAB OR ITS LICENSORS BE LIABLE OR
 * OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE
 * THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT,
 * PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY,
 * SERVICES, OR ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
 *
 * Should you have any questions regarding your right to use this Software, contact MbientLab via email:
 * hello@mbientlab.com.
 */

package com.mbientlab.metawear.module;

import com.mbientlab.metawear.AsyncDataProducer;
import com.mbientlab.metawear.MetaWearBoard.Module;

import java.util.Locale;

/**
 * Created by etsai on 11/12/16.
 */

public interface SensorFusion extends Module {
    enum AccRange {
        AR_2G,
        AR_4G,
        AR_8G,
        AR_16G,
    }

    enum GyroRange {
        GR_2000DPS,
        GR_1000DPS,
        GR_500DPS,
        GR_250DPS,
    }

    enum CalibrationAccuracy {
        UNRELIABLE,
        LOW_ACCURACY,
        MEDIUM_ACCURACY,
        HIGH_ACCURACY
    }

    enum Mode {
        SLEEP,
        NDOF,
        IMU_PLUS,
        COMPASS,
        M4G
    }

    final class EulerAngle {
        public final float heading, pitch, roll, yaw;

        public EulerAngle(float heading, float pitch, float roll, float yaw) {
            this.heading = heading;
            this.pitch = pitch;
            this.roll = roll;
            this.yaw = yaw;
        }

        @Override
        public boolean equals(Object o) {
            // Generated by IntelliJ
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            EulerAngle that = (EulerAngle) o;

            return Float.compare(that.heading, heading) == 0 && Float.compare(that.pitch, pitch) == 0 &&
                    Float.compare(that.roll, roll) == 0 && Float.compare(that.yaw, yaw) == 0;

        }

        @Override
        public String toString() {
            return String.format(Locale.US, "{heading %.3f, pitch: %.3f, roll: %.3f, yaw: %.3f}", heading, pitch, roll, yaw);
        }

        @Override
        public int hashCode() {
            // Generated by IntelliJ

            int result = (heading != +0.0f ? Float.floatToIntBits(heading) : 0);
            result = 31 * result + (pitch != +0.0f ? Float.floatToIntBits(pitch) : 0);
            result = 31 * result + (roll != +0.0f ? Float.floatToIntBits(roll) : 0);
            result = 31 * result + (yaw != +0.0f ? Float.floatToIntBits(yaw) : 0);
            return result;
        }
    }
    final class Quaternion {
        public final float w, x, y, z;

        public Quaternion(float w, float x, float y, float z) {
            this.w = w;
            this.x = x;
            this.y = y;
            this.z = z;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            Quaternion that = (Quaternion) o;

            return Float.compare(that.w, w) == 0 && Float.compare(that.x, x) == 0 &&
                    Float.compare(that.y, y) == 0 && Float.compare(that.z, z) == 0;

        }

        @Override
        public String toString() {
            return String.format(Locale.US, "{w: %.3f, x: %.3f, y: %.3f, z: %.3f}", w, x, y, z);
        }

        @Override
        public int hashCode() {
            int result = (w != +0.0f ? Float.floatToIntBits(w) : 0);
            result = 31 * result + (x != +0.0f ? Float.floatToIntBits(x) : 0);
            result = 31 * result + (y != +0.0f ? Float.floatToIntBits(y) : 0);
            result = 31 * result + (z != +0.0f ? Float.floatToIntBits(z) : 0);
            return result;
        }
    }
    final class CorrectedFloatVector3 {
        private final float x, y, z;
        private final CalibrationAccuracy accuracy;

        public CorrectedFloatVector3(float x, float y, float z, byte accuracy) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.accuracy = CalibrationAccuracy.values()[accuracy];
        }

        @Override
        public String toString() {
            return String.format(Locale.US, "{x: %.3f, y: %.3f, z: %.3f, accuracy: %s}", x, y, z, accuracy.toString());
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            CorrectedFloatVector3 that = (CorrectedFloatVector3) o;

            return Float.compare(that.x, x) == 0 && Float.compare(that.y, y) == 0 &&
                    Float.compare(that.z, z) == 0 && accuracy == that.accuracy;

        }

        @Override
        public int hashCode() {
            int result = (x != +0.0f ? Float.floatToIntBits(x) : 0);
            result = 31 * result + (y != +0.0f ? Float.floatToIntBits(y) : 0);
            result = 31 * result + (z != +0.0f ? Float.floatToIntBits(z) : 0);
            result = 31 * result + accuracy.hashCode();
            return result;
        }
    }

    interface ConfigEditor {
        ConfigEditor mode(Mode mode);
        ConfigEditor accRange(AccRange range);
        ConfigEditor gyroRange(GyroRange range);
        void commit();
    }

    ConfigEditor configure();

    AsyncDataProducer correctedAcceleration();
    AsyncDataProducer correctedRotation();
    AsyncDataProducer correctedBField();
    AsyncDataProducer quaternion();
    AsyncDataProducer eulerAngles();
    AsyncDataProducer gravity();
    AsyncDataProducer linearAcceleration();

    void start();
    void stop();
}
